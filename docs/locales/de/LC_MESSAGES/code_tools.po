# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2013-2020, The Royal Marsden NHS Foundation Trust
# This file is distributed under the same license as the OpenREM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2020.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: OpenREM 1.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-12-05 21:10+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"

#: ../../code_tools.rst:3
msgid "Tools and helper modules"
msgstr ""

#: ../../code_tools.rst:6
msgid "Get values"
msgstr ""

#: ../../code_tools.rst:7
msgid ""
"Tiny modules to reduce repetition in the main code when extracting "
"information from DICOM headers using pydicom."
msgstr ""

#: of openrem.remapp.tools.get_values.get_keys_by_value:1
msgid ""
"Get a list of keys from a dictionary which have the given value :param "
"dict_of_elements: a dictionary of elements :param value_to_find: the "
"value to look for in the dictionary :return: list of key names matching "
"the given value"
msgstr ""

#: of openrem.remapp.tools.get_values.get_or_create_cid:1
msgid ""
"Create a code_value code_meaning pair entry in the ContextID table if it "
"doesn't already exist."
msgstr ""

#: of openrem.remapp.tools.check_uid.check_uid
#: openrem.remapp.tools.check_uid.record_sop_instance_uid
#: openrem.remapp.tools.dcmdatetime.get_date
#: openrem.remapp.tools.dcmdatetime.get_date_time
#: openrem.remapp.tools.dcmdatetime.get_time
#: openrem.remapp.tools.dcmdatetime.make_date
#: openrem.remapp.tools.dcmdatetime.make_date_time
#: openrem.remapp.tools.dcmdatetime.make_dcm_date_range
#: openrem.remapp.tools.dcmdatetime.make_dcm_time
#: openrem.remapp.tools.dcmdatetime.make_dcm_time_range
#: openrem.remapp.tools.dcmdatetime.make_time
#: openrem.remapp.tools.get_values.get_or_create_cid
#: openrem.remapp.tools.get_values.get_seq_code_meaning
#: openrem.remapp.tools.get_values.get_seq_code_value
#: openrem.remapp.tools.get_values.get_value_kw
#: openrem.remapp.tools.get_values.get_value_num
#: openrem.remapp.tools.not_patient_indicators.get_not_pt
msgid "Parameters"
msgstr ""

#: of openrem.remapp.tools.get_values.get_or_create_cid:4
msgid "Code value as defined in the DICOM standard part 16"
msgstr ""

#: of openrem.remapp.tools.get_values.get_or_create_cid:6
msgid "Code meaning as defined in the DICOM standard part 16"
msgstr ""

#: of openrem.remapp.tools.check_uid.check_uid
#: openrem.remapp.tools.check_uid.record_sop_instance_uid
#: openrem.remapp.tools.dcmdatetime.get_date
#: openrem.remapp.tools.dcmdatetime.get_date_time
#: openrem.remapp.tools.dcmdatetime.get_time
#: openrem.remapp.tools.dcmdatetime.make_date
#: openrem.remapp.tools.dcmdatetime.make_date_time
#: openrem.remapp.tools.dcmdatetime.make_dcm_date_range
#: openrem.remapp.tools.dcmdatetime.make_dcm_time
#: openrem.remapp.tools.dcmdatetime.make_dcm_time_range
#: openrem.remapp.tools.dcmdatetime.make_time
#: openrem.remapp.tools.get_values.get_or_create_cid
#: openrem.remapp.tools.get_values.get_seq_code_meaning
#: openrem.remapp.tools.get_values.get_seq_code_value
#: openrem.remapp.tools.get_values.get_value_kw
#: openrem.remapp.tools.get_values.get_value_num
#: openrem.remapp.tools.not_patient_indicators.get_not_pt
msgid "Returns"
msgstr ""

#: of openrem.remapp.tools.get_values.get_or_create_cid:8
msgid "ContextID entry for code value passed"
msgstr ""

#: of openrem.remapp.tools.get_values.get_seq_code_meaning:1
msgid "From a DICOM sequence, get the code meaning."
msgstr ""

#: of openrem.remapp.tools.get_values.get_seq_code_meaning:3
#: openrem.remapp.tools.get_values.get_seq_code_value:3
msgid "DICOM sequence name."
msgstr ""

#: of openrem.remapp.tools.get_values.get_seq_code_meaning:5
#: openrem.remapp.tools.get_values.get_seq_code_value:5
msgid "The DICOM dataset containing the sequence."
msgstr ""

#: of openrem.remapp.tools.get_values.get_seq_code_meaning:7
msgid "str. -- code meaning"
msgstr ""

#: of openrem.remapp.tools.get_values.get_seq_code_value:1
msgid "From a DICOM sequence, get the code value."
msgstr ""

#: of openrem.remapp.tools.get_values.get_seq_code_value:7
msgid "int. -- code value"
msgstr ""

#: of openrem.remapp.tools.get_values.get_value_kw:1
msgid "Get DICOM value by keyword reference."
msgstr ""

#: of openrem.remapp.tools.dcmdatetime.get_date:3
#: openrem.remapp.tools.dcmdatetime.get_date_time:3
#: openrem.remapp.tools.dcmdatetime.get_time:3
#: openrem.remapp.tools.get_values.get_value_kw:3
msgid "DICOM keyword, no spaces or plural as per dictionary."
msgstr ""

#: of openrem.remapp.tools.dcmdatetime.get_date:5
#: openrem.remapp.tools.dcmdatetime.get_date_time:5
#: openrem.remapp.tools.dcmdatetime.get_time:5
#: openrem.remapp.tools.get_values.get_value_kw:5
#: openrem.remapp.tools.get_values.get_value_num:8
msgid "The DICOM dataset containing the tag."
msgstr ""

#: of openrem.remapp.tools.get_values.get_value_kw:7
#: openrem.remapp.tools.get_values.get_value_num:10
msgid "str. -- value"
msgstr ""

#: of openrem.remapp.tools.get_values.get_value_num:1
msgid "Get DICOM value by tag group and element number."
msgstr ""

#: of openrem.remapp.tools.get_values.get_value_num:3
msgid ""
"Always use get_value_kw by preference for readability. This module can be"
" required when reading private elements."
msgstr ""

#: of openrem.remapp.tools.get_values.get_value_num:6
msgid "DICOM group and element number as a single hexadecimal number (prefix 0x)."
msgstr ""

#: of openrem.remapp.tools.get_values.list_to_string:1
msgid ""
"Turn multivalue names into a single string for correct encoding and "
"pretty reproduction :param dicom_value: returned DICOM value, usually a "
"name field. Might be single (string) or multivalue (list) :return: string"
" of name(s)"
msgstr ""

#: of openrem.remapp.tools.get_values.return_for_export:1
msgid ""
"Prevent errors due to missing data in models :param model: database table"
" :param field: database field :return: value or None"
msgstr ""

#: of openrem.remapp.tools.get_values.test_numeric_value:1
msgid ""
"Tests if string can be converted to a float. If it can, return it :param "
"string_number: string to test if is a number :return: string if number, "
"nothing otherwise"
msgstr ""

#: ../../code_tools.rst:14
msgid "Check if UID exists"
msgstr ""

#: ../../code_tools.rst:15
msgid "Small module to check if UID already exists in the database."
msgstr ""

#: of openrem.remapp.tools.check_uid.check_uid:1
msgid "Check if UID already exists in database."
msgstr ""

#: of openrem.remapp.tools.check_uid.check_uid:3
msgid "Study UID."
msgstr ""

#: of openrem.remapp.tools.check_uid.check_uid:5
msgid "1 if it does exist, 0 otherwise"
msgstr ""

#: of openrem.remapp.tools.check_uid.record_sop_instance_uid:1
msgid ""
"Record the object's SOP Instance UID so we can ignore it next time. If an"
" object does need to be imported again, the original one needs to be "
"deleted first."
msgstr ""

#: of openrem.remapp.tools.check_uid.record_sop_instance_uid:4
msgid "GeneralStudyModuleAttr database object"
msgstr ""

#: of openrem.remapp.tools.check_uid.record_sop_instance_uid:5
msgid "SOP Instance UID of object being imported"
msgstr ""

#: ../../code_tools.rst:21
msgid "DICOM time and date values"
msgstr ""

#: ../../code_tools.rst:22
msgid "Module to convert betweeen DICOM and Python dates and times."
msgstr ""

#: of openrem.remapp.tools.dcmdatetime.get_date:1
msgid "Get DICOM date string and return Python date."
msgstr ""

#: of openrem.remapp.tools.dcmdatetime.get_date:7
#: openrem.remapp.tools.dcmdatetime.make_date:5
msgid "Python date value"
msgstr ""

#: of openrem.remapp.tools.dcmdatetime.get_date_time:1
msgid "Get DICOM date time string and return Python date time."
msgstr ""

#: of openrem.remapp.tools.dcmdatetime.get_date_time:7
#: openrem.remapp.tools.dcmdatetime.make_date_time:5
msgid "Python date time value"
msgstr ""

#: of openrem.remapp.tools.dcmdatetime.get_time:1
msgid "Get DICOM time string and return Python time."
msgstr ""

#: of openrem.remapp.tools.dcmdatetime.get_time:7
msgid "python time value"
msgstr ""

#: of openrem.remapp.tools.dcmdatetime.make_date:1
msgid "Given a DICOM date, return a Python date."
msgstr ""

#: of openrem.remapp.tools.dcmdatetime.make_date:3
msgid "DICOM style date."
msgstr ""

#: of openrem.remapp.tools.dcmdatetime.make_date_time:1
msgid "Given a DICOM date time, return a Python date time."
msgstr ""

#: of openrem.remapp.tools.dcmdatetime.make_date_time:3
msgid "DICOM style date time."
msgstr ""

#: of openrem.remapp.tools.dcmdatetime.make_dcm_date:1
msgid ""
"Given a Python date, return a DICOM date :param pythondate:  Date :type "
"pythondate:   Python date object :returns:           DICOM date as string"
msgstr ""

#: of openrem.remapp.tools.dcmdatetime.make_dcm_date_range:1
msgid "Given one or two dates of the form yyyy-mm-dd, return a DICOM date range."
msgstr ""

#: of openrem.remapp.tools.dcmdatetime.make_dcm_date_range:3
msgid "Date from, string, yyyy-mm-dd, 1900-01-01 if None or badly formatted"
msgstr ""

#: of openrem.remapp.tools.dcmdatetime.make_dcm_date_range:4
msgid "Date until, string, yyyy-mm-dd, today if None or badly formatted"
msgstr ""

#: of openrem.remapp.tools.dcmdatetime.make_dcm_date_range:5
msgid "Single date range, bool, default False"
msgstr ""

#: of openrem.remapp.tools.dcmdatetime.make_dcm_date_range:6
msgid "DICOM formatted date range or single date"
msgstr ""

#: of openrem.remapp.tools.dcmdatetime.make_dcm_time:1
msgid "Return DICOM formatted time without seconds from python time"
msgstr ""

#: of openrem.remapp.tools.dcmdatetime.make_dcm_time:3
msgid "Python datetime.time object"
msgstr ""

#: of openrem.remapp.tools.dcmdatetime.make_dcm_time:4
msgid "string, %H%M"
msgstr ""

#: of openrem.remapp.tools.dcmdatetime.make_dcm_time_range:1
msgid ""
"Given one or two times of the format 0123, return DICOM formatted time "
"range (without seconds)"
msgstr ""

#: of openrem.remapp.tools.dcmdatetime.make_dcm_time_range:3
msgid "time, format 0123, 0000 if None"
msgstr ""

#: of openrem.remapp.tools.dcmdatetime.make_dcm_time_range:4
msgid "time, format 0123, 2359 if None"
msgstr ""

#: of openrem.remapp.tools.dcmdatetime.make_dcm_time_range:5
msgid "time range, string, format 0123-1234"
msgstr ""

#: of openrem.remapp.tools.dcmdatetime.make_time:1
msgid "Given a DICOM time, return a Python time."
msgstr ""

#: of openrem.remapp.tools.dcmdatetime.make_time:3
msgid "DICOM style time."
msgstr ""

#: of openrem.remapp.tools.dcmdatetime.make_time:5
msgid "Python time value"
msgstr ""

#: ../../code_tools.rst:28
msgid "Test for QA or other non-patient related studies"
msgstr ""

#: of openrem.remapp.tools.not_patient_indicators.get_not_pt:1
msgid "Looks for indications that a study might be a test or QA study."
msgstr ""

#: of openrem.remapp.tools.not_patient_indicators.get_not_pt:3
msgid ""
"Some values that might indicate a study was for QA or similar purposes "
"are not recorded in the database, for example patient name. Therefore "
"this module attempts to find such indications and creates an xml style "
"string that can be recorded in the database on study import."
msgstr ""

#: of openrem.remapp.tools.not_patient_indicators.get_not_pt:8
msgid "The DICOM dataset."
msgstr ""

#: of openrem.remapp.tools.not_patient_indicators.get_not_pt:10
msgid "str. -- xml style string if any trigger values are found."
msgstr ""

#~ msgid "Get DICOM value by keyword reference."
#~ msgstr ""

#~ msgid "Parameters"
#~ msgstr ""

#~ msgid "DICOM keyword, no spaces or plural as per dictionary."
#~ msgstr ""

#~ msgid "The DICOM dataset containing the tag."
#~ msgstr ""

#~ msgid "Returns"
#~ msgstr ""

#~ msgid "str. -- value"
#~ msgstr ""

#~ msgid "Get DICOM value by tag group and element number."
#~ msgstr ""

#~ msgid ""
#~ "Always use get_value_kw by preference "
#~ "for readability. This module can be "
#~ "required when reading private elements."
#~ msgstr ""

#~ msgid ""
#~ "DICOM group and element number as "
#~ "a single hexadecimal number (prefix 0x)."
#~ msgstr ""

#~ msgid "From a DICOM sequence, get the code value."
#~ msgstr ""

#~ msgid "DICOM sequence name."
#~ msgstr ""

#~ msgid "The DICOM dataset containing the sequence."
#~ msgstr ""

#~ msgid "int. -- code value"
#~ msgstr ""

#~ msgid "From a DICOM sequence, get the code meaning."
#~ msgstr ""

#~ msgid "str. -- code meaning"
#~ msgstr ""

#~ msgid ""
#~ "Create a code_value code_meaning pair "
#~ "entry in the ContextID table if it"
#~ " doesn't already exist."
#~ msgstr ""

#~ msgid "Code value as defined in the DICOM standard part 16"
#~ msgstr ""

#~ msgid "Code meaning as defined in the DICOM standard part 16"
#~ msgstr ""

#~ msgid "ContextID entry for code value passed"
#~ msgstr ""

#~ msgid ""
#~ "Prevent errors due to missing data "
#~ "in models :param model: database table"
#~ " :param field: database field :return: "
#~ "value or None"
#~ msgstr ""

#~ msgid ""
#~ "Tests if string can be converted "
#~ "to a float. If it can, return "
#~ "it :param string_number: string to test"
#~ " if is a number :return: string "
#~ "if number, nothing otherwise"
#~ msgstr ""

#~ msgid ""
#~ "Function to encode non-ASCII characters"
#~ " correctly. Probably not required any "
#~ "longer, but leaving in for now. "
#~ ":param string: String to encode :param"
#~ " char_set: Character set used by "
#~ "DICOM file :return: Encoded string"
#~ msgstr ""

#~ msgid ""
#~ "Turn multivalue names into a single "
#~ "string for correct encoding and pretty"
#~ " reproduction :param dicom_value: returned "
#~ "DICOM value, usually a name field. "
#~ "Might be single (string) or multivalue"
#~ " (list) :return: string of name(s)"
#~ msgstr ""

#~ msgid ""
#~ "Get a list of keys from a "
#~ "dictionary which have the given value"
#~ " :param dict_of_elements: a dictionary of"
#~ " elements :param value_to_find: the value"
#~ " to look for in the dictionary "
#~ ":return: list of key names matching "
#~ "the given value"
#~ msgstr ""

#~ msgid "Check if UID already exists in database."
#~ msgstr ""

#~ msgid "Study UID."
#~ msgstr ""

#~ msgid "1 if it does exist, 0 otherwise"
#~ msgstr ""

#~ msgid ""
#~ "Record the object's SOP Instance UID "
#~ "so we can ignore it next time. "
#~ "If an object does need to be "
#~ "imported again, the original one needs"
#~ " to be deleted first."
#~ msgstr ""

#~ msgid "GeneralStudyModuleAttr database object"
#~ msgstr ""

#~ msgid "SOP Instance UID of object being imported"
#~ msgstr ""

#~ msgid "Get DICOM date string and return Python date."
#~ msgstr ""

#~ msgid "Python date value"
#~ msgstr ""

#~ msgid "Get DICOM time string and return Python time."
#~ msgstr ""

#~ msgid "python time value"
#~ msgstr ""

#~ msgid "Get DICOM date time string and return Python date time."
#~ msgstr ""

#~ msgid "Python date time value"
#~ msgstr ""

#~ msgid "Given a DICOM date, return a Python date."
#~ msgstr ""

#~ msgid "DICOM style date."
#~ msgstr ""

#~ msgid "Given a DICOM time, return a Python time."
#~ msgstr ""

#~ msgid "DICOM style time."
#~ msgstr ""

#~ msgid "Python time value"
#~ msgstr ""

#~ msgid "Given a DICOM date time, return a Python date time."
#~ msgstr ""

#~ msgid "DICOM style date time."
#~ msgstr ""

#~ msgid ""
#~ "Given a Python date, return a "
#~ "DICOM date :param pythondate:  Date "
#~ ":type pythondate:   Python date object "
#~ ":returns:           DICOM date as string"
#~ msgstr ""

#~ msgid ""
#~ "Given one or two dates of the "
#~ "form yyyy-mm-dd, return a DICOM"
#~ " date range."
#~ msgstr ""

#~ msgid "Date from, string, yyyy-mm-dd, 1900-01-01 if None or badly formatted"
#~ msgstr ""

#~ msgid "Date until, string, yyyy-mm-dd, today if None or badly formatted"
#~ msgstr ""

#~ msgid "Single date range, bool, default False"
#~ msgstr ""

#~ msgid "DICOM formatted date range or single date"
#~ msgstr ""

#~ msgid "Return DICOM formatted time without seconds from python time"
#~ msgstr ""

#~ msgid "Python datetime.time object"
#~ msgstr ""

#~ msgid "string, %H%M"
#~ msgstr ""

#~ msgid ""
#~ "Given one or two times of the "
#~ "format 0123, return DICOM formatted time"
#~ " range (without seconds)"
#~ msgstr ""

#~ msgid "time, format 0123, 0000 if None"
#~ msgstr ""

#~ msgid "time, format 0123, 2359 if None"
#~ msgstr ""

#~ msgid "time range, string, format 0123-1234"
#~ msgstr ""

#~ msgid "Looks for indications that a study might be a test or QA study."
#~ msgstr ""

#~ msgid ""
#~ "Some values that might indicate a "
#~ "study was for QA or similar "
#~ "purposes are not recorded in the "
#~ "database, for example patient name. "
#~ "Therefore this module attempts to find"
#~ " such indications and creates an xml"
#~ " style string that can be recorded"
#~ " in the database on study import."
#~ msgstr ""

#~ msgid "The DICOM dataset."
#~ msgstr ""

#~ msgid "str. -- xml style string if any trigger values are found."
#~ msgstr ""

#~ msgid "OpenREM settings"
#~ msgstr ""

#~ msgid ""
#~ "Administrative module to define the name"
#~ " of the project and to add it"
#~ " to the Python path"
#~ msgstr ""

